
==================== FINAL INTERFACE ====================
2017-12-06 02:54:11.399863 UTC

interface haskell-words-0.1.0.0-1KENKS1h3Aj7RTqdk2mv5B:Lib 8002
  interface hash: dce03b9bef508d129599bec8b71bbf56
  ABI hash: 3b4ece1059570ba2ec91b62ae21e0dd1
  export-list hash: 48ba2be00bad7d1e746be9409e408255
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: f6624f22fcdd76ed0ac6625466e2d712
  sig of: Nothing
  used TH splices: False
  where
exports:
  Lib.findWord
  Lib.findWordInLine
  Lib.findWords
  Lib.formatGrid
  Lib.getLines
  Lib.outputGrid
  Lib.skew
module dependencies:
package dependencies: base-4.9.1.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Either base-4.9.1.0:Data.Functor.Const
                         base-4.9.1.0:Data.Monoid base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:GHC.Generics base-4.9.1.0:GHC.IO.Exception
                         base-4.9.1.0:GHC.TypeLits
import  -/  base-4.9.1.0:Data.Foldable 3e0b6967a1da89945d0e2d47266337a2
import  -/  base-4.9.1.0:Data.List 07ae2acca6538aa0800bd0a993ac6ac1
import  -/  base-4.9.1.0:Data.Maybe d876c4ffe4b3c43755a781e8ad860d88
import  -/  base-4.9.1.0:Data.OldList 27987919d8da2f92e3f472ca81f730f8
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.List ab8c4e523e6c479c549d3bcd5fc4a439
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  base-4.9.1.0:System.IO c9de64c5f5407c4cf1c52500c4d15200
import  -/  ghc-prim-0.5.0.0:GHC.Types 89f8de4f08018c9177c98d979eae0e45
081887f7018a658419a0d92225ebb06a
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Lib.$trModule2 Lib.$trModule1) -}
d0343e33bd3e710ec6d5789097acf3c1
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Lib"#) -}
7f41633553a831d387d3952893c92af2
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "haskell-words-0.1.0.0-1KENKS1h3Aj7RTqdk2mv5B"#) -}
940fd5d9272b4daf5d43dd1ea545476f
  type Grid = [GHC.Base.String]
702480b275c76476f7105fa9682ee853
  findWord ::
    Lib.Grid -> GHC.Base.String -> GHC.Base.Maybe GHC.Base.String
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><L,U>,
     Unfolding: (\ (grid :: Lib.Grid) (word :: GHC.Base.String) ->
                 letrec {
                   go :: [[GHC.Types.Char]] -> Data.Monoid.Any
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [[GHC.Types.Char]]) ->
                     case ds of wild {
                       [] -> GHC.Types.False `cast` (Sym (Data.Monoid.N:Any[0]))
                       : y ys
                       -> case Data.OldList.isInfixOf
                                 @ GHC.Types.Char
                                 GHC.Classes.$fEqChar
                                 word
                                 y of wild1 {
                            GHC.Types.False -> go ys
                            GHC.Types.True
                            -> GHC.Types.True `cast` (Sym (Data.Monoid.N:Any[0])) } }
                 } in
                 case (go (Lib.getLines grid))
                        `cast`
                      (Data.Monoid.N:Any[0]) of wild {
                   GHC.Types.False -> GHC.Base.Nothing @ GHC.Base.String
                   GHC.Types.True -> GHC.Base.Just @ GHC.Base.String word }) -}
786b62f4e0a5a6dfd11054330c7cf289
  findWordInLine ::
    GHC.Base.String -> GHC.Base.String -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Unfolding: (Data.OldList.isInfixOf
                   @ GHC.Types.Char
                   GHC.Classes.$fEqChar) -}
6bc4942605d20523e46be244f6b4b9d3
  findWords :: Lib.Grid -> [GHC.Base.String] -> [GHC.Base.String]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (grid :: Lib.Grid) (words :: [GHC.Base.String]) ->
                 Data.Maybe.catMaybes1
                   @ GHC.Base.String
                   (GHC.Base.build
                      @ (GHC.Base.Maybe GHC.Base.String)
                      (\ @ b1
                         (c :: GHC.Base.Maybe GHC.Base.String -> b1 -> b1)[OneShot]
                         (n :: b1)[OneShot] ->
                       GHC.Base.foldr
                         @ [GHC.Types.Char]
                         @ b1
                         (GHC.Base.mapFB
                            @ (GHC.Base.Maybe GHC.Base.String)
                            @ b1
                            @ [GHC.Types.Char]
                            c
                            (Lib.findWord grid))
                         n
                         words))) -}
8fce1011a06b22c0cd564accb350a6f0
  formatGrid :: Lib.Grid -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True) Data.OldList.unlines -}
e3483c612e719a17a3cba32e03c6d430
  getLines :: Lib.Grid -> [GHC.Base.String]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>,
     Unfolding: (\ (grid :: Lib.Grid) ->
                 let {
                   lines :: [GHC.Base.String]
                   = GHC.Base.++
                       @ [GHC.Types.Char]
                       grid
                       (GHC.Base.++
                          @ [GHC.Types.Char]
                          (Data.OldList.transpose @ GHC.Types.Char grid)
                          (GHC.Base.++
                             @ [GHC.Types.Char]
                             (Data.OldList.transpose @ GHC.Types.Char (Lib.skew grid))
                             (Data.OldList.transpose
                                @ GHC.Types.Char
                                (Lib.skew
                                   (GHC.Base.map
                                      @ [GHC.Types.Char]
                                      @ [GHC.Types.Char]
                                      (GHC.List.reverse @ GHC.Types.Char)
                                      grid)))))
                 } in
                 GHC.Base.++
                   @ [GHC.Types.Char]
                   lines
                   (GHC.Base.map
                      @ [GHC.Types.Char]
                      @ [GHC.Types.Char]
                      (GHC.List.reverse @ GHC.Types.Char)
                      lines)) -}
3d4ec35dee5704c80f8d2915ba02619a
  outputGrid :: Lib.Grid -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <L,1*U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Lib.outputGrid1
                  `cast`
                (<Lib.Grid>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
b3eaad521050de82c38d9872272fe8b1
  outputGrid1 ::
    Lib.Grid
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <L,1*U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (grid :: Lib.Grid)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 GHC.IO.Handle.Text.hPutStr2
                   GHC.IO.Handle.FD.stdout
                   (Data.OldList.unlines grid)
                   GHC.Types.True
                   eta) -}
1744c43e26355edd3c2af7a19a87e2c1
  skew :: Lib.Grid -> Lib.Grid
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

